<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<script>
// 全局变量用于存储被注册的副作用函数
let activeEffect;
// 创建存储副作用函数的桶
const bucket = new WeakMap();
// 原始数据
const data = {
    name:"pingping",
    age:18,
    flag:true
}

// 响应式函数
const state = new Proxy(data,{
    // 拦截读取操作
    get(target, key){
        // 将副作用函数activeEffect添加到存储副作用函数的WeakMap中
        track(target, key)
        // 返回属性值
        return target[key]
    },
    // 拦截设值操作
    set(target, key, newVal){
        // 设置属性值
        target[key] = newVal;
        // 将副作用函数从WeakMap中取出并执行
        trigger(target, key)
    }
})

// 在get拦截函数中调用追踪取值函数的变化
function track(target, key){
    // 没有activeEffect
    if(!activeEffect) return
    // 根据目标对象从桶中获得副作用函数
    let depsMap = bucket.get(target);
    // 判断是否存在，不存在则创建一个Map
    if(!depsMap) bucket.set(target, depsMap = new Map())
    // 根据key从depsMap取的deps，存储着与key相关的副作用函数
    let deps = depsMap.get(key);
    // 判断key对应的副作用函数是否存在
    if(!deps) depsMap.set(key, deps = new Set())
    // 最后将激活的副作用函数添加到桶里
    deps.add(activeEffect)
    // deps是与当前副作用函数存在联系的依赖集合
    activeEffect.deps.push(deps)
}

// 在set拦截函数中调用trigger函数触发变化
function trigger(target, key){
    // 根据target从桶中取的depMaps
    const depMaps = bucket.get(target);
    // 判断是否存在
    if(!depMaps) return
    // 根据key值取得对应的副作用函数
    const effects = depMaps.get(key);
    const effectsToRun = new Set();
    // 执行副作用函数
    effects && effects.forEach(effectFn=>{
        if(effectFn !== activeEffect){
            effectsToRun.add(effectFn)
        }
    })
    effectsToRun.forEach(effectFn=>{
        // 如果副作用函数中存在调度器
        if(effectFn.options?.scheduler){
            effectFn.options.scheduler(effectFn)
        }else{
            effectFn()
        }
    });
}

let effectStack = [];
// effect用于注册副作用函数
function effect(fn,options={}){
    const effectFn = ()=>{
        // 调用函数完成清理遗留副作用函数
        cleanupEffect(effectFn)
        // 当调用effect注册副作用函数时，将副作用函数fn赋值给activeEffect
        activeEffect = effectFn;
        // 在副作用函数执行前压栈
        effectStack.push(effectFn)
        // 执行副作用函数，将执行结果存储到res中
        const res = fn();
        // 执行完毕后出栈
        effectStack.pop()
        activeEffect = effectStack[effectStack.length - 1]
        // 将res作为effectFn的返回值
        return  res
    }
    // 将options挂载到effectFn函数上
    effectFn.options = options
    //deps是用于存储所有与该副作用函数相关联的依赖集合
    effectFn.deps = [];
    // 只有非lazy的时候才执行
    if(!options.lazy){
        // 执行副作用函数effectFn
        effectFn()
    }
    //否则返回副作用函数
    return effectFn
    
}

// 遗留的副作用函数的清除函数
function cleanupEffect(effectFn){          
    const { deps } = effectFn
    // 遍历依赖集合数组
    for(let i = 0; i < deps.length; i++){
        //从依赖集合中删除
        deps[i].delete(effectFn)
    }
    // 重置数组
    deps.length = 0
}

function computed(getter){
  let value;
  let dirty = true;

  const effectFn = effect(
    getter,
    {
        //指定lazy选项，这样函数不会立即执行
        lazy: true,
        //在调度器重置dirty为true
        scheduler(){
            dirty = true
            trigger(state, "value")
        }
    }
  );
  
  const state = {
    //当对value进行读取操作时，执行effectFn并将结果进行返回
    get value(){
      //只有当dirty标识为true值时，才会将计算值进行缓存，下一次访问直接使用缓存的值
      if(dirty){
        value = effectFn();
        dirty = false
      }
      // 对value进行取值操作时，手动调用track函数进行追踪
      track(state, "value")
      return value
    }
  }
  return state;
}

const isObject = (value) => typeof value === "object" && value !== null;

function traverse(value, seen = new Set()){
  //如果读取的数据是原始值，或已经读取过响应数据，则什么也不做
  if(!isObject(value) || seen.has(value)) return;
  //将数据添加到seen中，表示遍历读取过数据，避免循环引用导致死循环
  seen.add(value);
  //对数据对象进行遍历递归读取，用于依赖收集
  for(const k in value){
    traverse(value[k],seen);
  }
  return value;
}

function watch(source,cb){
    let getter;
    if(typeof source === "function"){ // 如果是函数表示是getter，可以直接赋值
       getter = source;
    }else{
       getter = () => traverse(source)// 包装成effect对应的effectFn, 函数内部进行遍历达到依赖收集的目的
    }
    let oldValue, newValue;
    const effectFn = effect(
      ()=>getter(),
      {
        //开启lazy选项，将返回值存储到effectFn中以便于之后手动调用
        lazy: true,
        scheduler(){
          newValue = effectFn(); // 值变化时再次运行effect函数,获取新值
          cb(newValue,oldValue);
          //更新旧值，不然下次得到的是错误的旧值
          oldValue = newValue;
        }
      }
    )
    //手动调用副作用函数，拿到的值是旧值
    oldValue = effectFn();
}

watch(()=>state.age,(newValue, oldValue)=>{
    console.log(newValue, oldValue);
})

state.age++

</script>
</body>
</html>